# -*- coding: utf-8 -*-
"""cnn_run_backend.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s5v0p75U4peWJdAJN1djgMYUigHclF9-
"""

def run_model(a, start, end):
  import warnings
  warnings.filterwarnings("ignore")

  if a == 1:
    return make_forecast(df_provided=None, start=start, end=end, a=a)
  if a == 2:
    return view_historical_data(start, end)
  if a == 3:
    return test_predictions(start, end)
  if a == 4:
    return view_festival_data(start, end)

def make_forecast(df_provided=None, start=None, end=None, a=None):

  import pandas as pd
  import numpy as np
  import datetime

  start = datetime.datetime.strptime(start, '%Y-%m-%d %H:%M')
  end = datetime.datetime.strptime(end, '%Y-%m-%d %H:%M')

  if end<start:
      dummy = start
      start = end
      end = dummy

  df = pd.read_csv(r'basic/data/megawatts.csv')

  fest = pd.read_csv(r'basic/data/festival.csv')

  df['datetime'] = pd.to_datetime(df['datetime'])
  fest['date'] = pd.to_datetime(fest['date'])

  if df_provided == None:
    no_of_predictions = int(((end - start).total_seconds()/900) + 1)

    df_more = pd.DataFrame(np.zeros((no_of_predictions))).rename(columns={0:'load'})
    df_more['datetime'] = pd.date_range(start, end, freq = '0.25H')

    df_copy = pd.concat([df, df_more], sort=False, axis=0)
    df_new = mach3(df_copy, fest, [-1, -2, -3, 0, 1, 2, 3], 12, 12)
    df_new = df_new.drop(columns = ['load'], axis=1)

  else:
    df_new = mach3(df, fest, [-1, -2, -3, 0, 1, 2, 3], 12, 12)
    df_copy = df_new.reset_index(drop=True)
    df_copy['datetime'] = df_new.index
    df_new = df_new.drop(columns = ['load'], axis=1)

  from sklearn.preprocessing import MinMaxScaler
  scaler = MinMaxScaler()
  scaler.fit(df_new)
  X = scaler.transform(df_new.loc[start:end])
  X = X.reshape(X.shape[0], 6, 7, 4)

  from tensorflow.keras.models import load_model
  model = load_model('basic/data/sE19_R83.hdf5')
  Y = model.predict(X)

  target_scaler = MinMaxScaler()
  target_scaler.fit(np.array(df['load']).reshape(-1, 1))
  Y_scaled_back = target_scaler.inverse_transform(Y)

  df_copy.set_index('datetime', inplace=True, drop='True')
  df_copy.loc[start:end, 'load'] = Y_scaled_back.reshape(-1,)

  if a == 3:
    result = df_copy.loc[start:end, 'load'].to_frame()
    result_foo = result.rename(columns={'load':'predicted load'})
    result_foo['actual load'] = df.set_index('datetime').loc[start:end, 'load']
    result_foo.to_csv("basic/static/basic/data/result.csv")
    return plot(result, start, end, 3)

  else:
    result = df_copy.loc[start:end, 'load']
    result.to_csv("basic/static/basic/data/result.csv")
    return plot(result, start, end, 1)

def create_regressor_attributes(df, attribute, list_of_t_instants) :

  import pandas as pd

  list_of_t_instants.sort()
  start = -1 * list_of_t_instants[0]
  if list_of_t_instants[-1] > 0 :
      end = len(df) - list_of_t_instants[-1]
  else:
      end = len(df)
  if df.index.name == None:
      dummy = 0
      df.loc[:, 'new_index'] = df.index
  else:
      dummy = 1
      new_index_name = df.index.name
      df.loc[:, new_index_name] = df.index
  df.reset_index(drop=True)

  df_copy = df.iloc[start:end]
  df_copy.reset_index(inplace=True, drop=True)

  for attribute in attribute :
          foobar = pd.DataFrame()

          for t in list_of_t_instants :
              if t>0:
                  sign = '+'
              else:
                  sign = ''
              new_col = pd.DataFrame(df.loc[:, attribute].iloc[(start + t) : (end + t)])
              new_col.reset_index(drop=True, inplace=True)
              new_col.rename(columns={attribute : '{}_(t{}{})'.format(attribute, sign, t)}, inplace=True)
              foobar = pd.concat([foobar, new_col], sort=False, axis=1)

          df_copy = pd.concat([df_copy, foobar], sort=False, axis=1)

  if dummy == 0:
      df_copy.set_index(['new_index'], drop=True, inplace=True)
      df.drop(columns=['new_index'], inplace=True)
  elif dummy == 1:
      df_copy.set_index([new_index_name], drop=True, inplace=True)
      df.drop(columns=[new_index_name], inplace=True)
  return df_copy

def create_daily_reg(df, window, day_slots):

    import pandas as pd

    day_regressors = []
    for j in window:
        for i in day_slots:
            day_regressors .append(i+j)

    day_regressors = [-i for i in sorted(day_regressors)]
    day_df = create_regressor_attributes(df, ['load'], day_regressors)
    return day_df

def create_week_reg(df, fest, window, week_slots):

    import pandas as pd
    import datetime

    df['datetime'] = pd.to_datetime(df['datetime'])
    fest['date'] = pd.to_datetime(fest['date'])
    df = df.set_index(df['datetime'].dt.date)
    fest = fest.set_index('date')
    df = df.join(fest)
    df['occasion'] = (~df['occasion'].isnull()).astype(int)
    df['weekday'] = df['datetime'].dt.weekday
    holiday = set(df.loc[df['occasion'] == 1].index)
    Sunday = set(df.loc[df['weekday'] == 6].index)
    next_to_holiday = [day + datetime.timedelta(days=1) for day in holiday]
    next_to_holiday = [day for day in next_to_holiday if day not in holiday]
    next_to_holiday = set([day for day in next_to_holiday if day not in Sunday])
    df.loc[holiday, 'weekday'] = 6
    df.loc[next_to_holiday, 'weekday'] = 0
    df = df.set_index('datetime')
    df = df.drop(columns =['occasion'])

    week_regressors = []
    for j in window:
        for i in week_slots:
          week_regressors .append(i+j)

    week_regressors = [-i for i in sorted(week_regressors)]
    weekwise = []
    for day in set(df['weekday']):
        weekwise.append(df.loc[df['weekday'] == day])

    week_col_names = pd.DataFrame(['t-w{}'.format(len(week_regressors)-i) for i in range(len(week_regressors))])
    week_col_names  = week_col_names.set_index(pd.Series([f'load_(t{j})' for j in sorted(week_regressors)]))
    week_col_names = week_col_names.to_dict()[0]
    for i in range(len(weekwise)):
        weekwise[i] = create_regressor_attributes(weekwise[i], ['load'], week_regressors).rename(columns=week_col_names)

    week_df = pd.concat(weekwise)
    week_df = week_df.sort_index()

    return week_df

def mach3(df, fest, window, d_number, w_number):

    import pandas as pd
    week_slots = [96*i for i in range(1, w_number+1)]
    week_df = create_week_reg(df, fest, window, week_slots)
    day_slots = [96*i for i in range(1, d_number+1+d_number//7) if i%7!=0]
    final_df = create_daily_reg(week_df, window, day_slots)
    final_df = final_df[final_df.columns[::-1]]
    final_df = final_df.drop(columns = ['weekday'])
    return final_df


def plot(result, start, end, a):

  from matplotlib import pyplot as plt
  import pandas as pd
  import numpy as np

  if len(result) > 15:
    plt.figure(figsize=(15, 6))
    plt.plot(result, linewidth=2, color='r', linestyle='solid', label='Predicted')
    if a == 1:
      plt.title("Forecast from '{}' to '{}'".format(start, end), weight='bold', fontsize=16)
    if a == 2:
      plt.title("Historical Load from '{}' to '{}'".format(start, end), weight='bold', fontsize=16)
    if a == 3:
      plt.title("Prediction vs Actual from '{}' to '{}'".format(start, end), weight='bold', fontsize=16)
      df = pd.read_csv(r'basic/data/megawatts.csv')
      df['datetime'] = pd.to_datetime(df['datetime'])
      df = df.set_index('datetime', drop=True)
      plt.plot(df.loc[start:end], linewidth=2, color='b', linestyle='dotted', label='Actual')
      plt.legend(loc='best')
    plt.grid(color='y', linewidth=0.5)
    plt.xticks(weight='bold', fontsize=12)
    plt.yticks(weight='bold', fontsize=12)
    plt.xlabel('Datetime', weight='bold', fontsize=14)
    plt.ylabel('MegaWatts', weight='bold', fontsize=14)
    plt.savefig('basic/static/basic/data/result.png', bbox_inches='tight', pad_inches = 0.3)
  else:
    if a==3:
      df = pd.read_csv(r'basic/data/megawatts.csv')
      df['datetime'] = pd.to_datetime(df['datetime'])
      df = df.set_index('datetime', drop=True)
      df = df.loc[start:end]
      df = df.rename(columns={'load':'actual load'})
      df['predicted load'] = result['load']
      df = df.reset_index()
      render_mpl_table(df, header_columns=0, col_width=3.0)
    else:
      df = result.reset_index()
      render_mpl_table(df, header_columns=0, col_width=3.0)

def view_historical_data(start, end):

  import pandas as pd

  if end<start:
      dummy = start
      start = end
      end = dummy

  df = pd.read_csv(r'basic/data/megawatts.csv')
  df['datetime'] = pd.to_datetime(df['datetime'])

  df = df.set_index('datetime', drop=True)

  df.loc[start:end].to_csv("basic/static/basic/data/result.csv")

  return plot(df.loc[start:end], start, end, 2)

def view_festival_data(start, end):

    import pandas as pd
    import datetime

    if end<start:
        dummy = start
        start = end
        end = dummy

    df = pd.read_csv(r'basic/data/festival.csv')
    df['date'] = pd.to_datetime(df['date'])
    df = df.set_index('date', drop=True)
    df = df.loc[start:end]
    df.to_csv("basic/static/basic/data/result.csv")
    df = df.reset_index()
    df['date'] = df['date'].apply(lambda x: datetime.datetime.strftime(x, format='%Y-%m-%d'))
    render_mpl_table(df, header_columns=0, col_width=3.0)


def test_predictions(start, end):
  import numpy as np
  import pandas as pd
  import datetime

  df = pd.read_csv(r'basic/data/megawatts.csv')
  df['datetime'] = pd.to_datetime(df['datetime'])

  return make_forecast(df_provided=True, start=start, end=end, a=3)


def render_mpl_table(data, col_width=3.0, row_height=0.625, font_size=14,
                     header_color='#40466e', row_colors=['#f1f1f2', 'w'], edge_color='w',
                     bbox=[0, 0, 1, 1], header_columns=0,
                     ax=None, **kwargs):

    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    import six

    if ax is None:
        size = (np.array(data.shape[::-1]) + np.array([0, 1])) * np.array([col_width, row_height])
        fig, ax = plt.subplots(figsize=size)
        ax.axis('off')

    mpl_table = ax.table(cellText=data.values, bbox=bbox, colLabels=data.columns, **kwargs)

    mpl_table.auto_set_font_size(False)
    mpl_table.set_fontsize(font_size)

    for k, cell in  six.iteritems(mpl_table._cells):
        cell.set_edgecolor(edge_color)
        if k[0] == 0 or k[1] < header_columns:
            cell.set_text_props(weight='bold', color='w')
            cell.set_facecolor(header_color)
        else:
            cell.set_facecolor(row_colors[k[0]%len(row_colors) ])
    plt.savefig('basic/static/basic/data/result.png', bbox_inches='tight', pad_inches = 0.1)
    return ax
